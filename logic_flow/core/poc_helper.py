"""
PoC Helper Module for Security Research and Exploit Development

This module provides automated WinDbg script generation and security insights
for vulnerability research and proof-of-concept development.
"""

import logging
from typing import Dict, List, Optional, Set, Tuple, Any
from pathlib import Path
from enum import Enum
from dataclasses import dataclass

logger = logging.getLogger(__name__)


class ChangeType(Enum):
    """Types of changes identified in function comparison"""
    ADDED_SECURITY_CHECK = "added_security_check"
    REMOVED_CODE = "removed_code"
    LOGIC_REORDER = "logic_reorder"
    UNCHANGED = "unchanged"
    UNKNOWN = "unknown"


@dataclass
class SecurityInsight:
    """Represents a security-relevant insight from comparison"""
    function_address: int
    function_name: str
    change_type: ChangeType
    risk_level: str  # "HIGH", "MEDIUM", "LOW"
    description: str
    reachable_from_ioctl: bool = False
    ioctl_codes: List[str] = None
    windbg_breakpoint: str = ""
    exploit_potential: str = ""

    def __post_init__(self):
        if self.ioctl_codes is None:
            self.ioctl_codes = []


class PoCHelper:
    """Helper class for PoC development and security research"""

    def __init__(self):
        # Security patterns that indicate vulnerability fixes
        self._security_patterns = {
            'validation_functions': {
                'ProbeForRead', 'ProbeForWrite', 'SeAccessCheck', 'RtlEqualSid',
                'ZwQuerySecurityObject', 'SeQueryAuthenticationIdToken'
            },
            'error_checks': {
                'NT_SUCCESS', 'NT_ERROR', 'STATUS_SUCCESS', 'STATUS_ACCESS_DENIED'
            },
            'allocation_functions': {
                'ExAllocatePool', 'ExAllocatePoolWithTag', 'ExAllocatePoolWithQuotaTag',
                'ExAllocatePool2', 'ExAllocatePool3'
            },
            'handle_functions': {
                'ObReferenceObjectByHandle', 'ZwOpenFile', 'ZwCreateFile'
            }
        }

        # IOCTL-related patterns
        self._ioctl_patterns = {
            'dispatcher_patterns': {
                'IoGetCurrentIrpStackLocation', 'irp', 'IRP_MJ_', 'IoCallDriver'
            },
            'ioctl_handlers': {
                'IOCTL_', 'METHOD_', 'FILE_', 'IRP_MJ_DEVICE_CONTROL'
            }
        }

    def generate_windbg_script(self, diff_results: Dict[str, Any], output_path: str) -> str:
        """
        Generate WinDbg JavaScript script for dynamic analysis of patched functions.

        Enhanced version with better breakpoint generation, data flow tracing,
        and exploit development support.

        Args:
            diff_results: Results from logic flow comparison
            output_path: Path to save the generated script

        Returns:
            Path to the generated script file
        """
        try:
            script_lines = []
            script_lines.append("// Auto-generated WinDbg JavaScript for Security Research & PoC Development")
            script_lines.append("// Generated by Logic Flow Analysis Tool")
            script_lines.append("// Use: .scriptload <path_to_this_file>")
            script_lines.append("// Target: Analyze patched driver logic and potential vulnerabilities")
            script_lines.append("")

            # Get security insights and changed functions
            security_insights = self._analyze_security_insights(diff_results)
            attack_surface = diff_results.get("attack_surface_analysis", {})
            patch_classification = diff_results.get("patch_classification", {})

            # Generate initialization
            script_lines.append("// INITIALIZATION")
            script_lines.append("host.diagnostics.debugLog('=== Logic Flow Analysis WinDbg Script ===\\n');")
            script_lines.append("host.diagnostics.debugLog('Analyzing patched driver for security insights\\n\\n');")
            script_lines.append("")

            # Generate breakpoints for high-priority security targets
            high_priority_targets = [i for i in security_insights if i.risk_level == "HIGH"]
            if high_priority_targets:
                script_lines.append("// CRITICAL SECURITY BREAKPOINTS - HIGH PRIORITY TARGETS")
                script_lines.append("// These functions have security-relevant changes and are reachable from IOCTL")
                script_lines.append("")
                for insight in high_priority_targets:
                    if insight.reachable_from_ioctl and insight.ioctl_codes:
                        script_lines.append(f"// {insight.description}")
                        script_lines.append(f"// Risk Level: {insight.risk_level} | IOCTL Codes: {', '.join(insight.ioctl_codes)}")
                        script_lines.append(f"// Exploit Potential: {insight.exploit_potential}")
                        script_lines.append(f'bp DriverB!{insight.function_name} ".echo \\"[CRITICAL] Hit security-critical function {insight.function_name}\\"; .printf \\"Potential vulnerability: {insight.description}\\"; g"')
                        script_lines.append("")

            # Generate breakpoints for added security checks (patch analysis)
            added_security_checks = [i for i in security_insights if i.change_type == ChangeType.ADDED_SECURITY_CHECK]
            if added_security_checks:
                script_lines.append("// ADDED SECURITY CHECKS - PATCH ANALYSIS")
                script_lines.append("// Monitor these newly added validation routines")
                script_lines.append("")
                for insight in added_security_checks:
                    script_lines.append(f"// {insight.description}")
                    script_lines.append(f'bp DriverB!{insight.function_name} ".echo \\"[PATCH] Hit added security check in {insight.function_name}\\"; .printf \\"Security improvement: {insight.description}\\"; g"')
                    script_lines.append("")

            # Generate breakpoints for removed error handling (potential vulnerabilities)
            removed_error_handlers = [i for i in security_insights if i.change_type == ChangeType.REMOVED_CODE]
            if removed_error_handlers:
                script_lines.append("// REMOVED ERROR HANDLING - POTENTIAL VULNERABILITIES")
                script_lines.append("// These functions had error handling removed - high risk")
                script_lines.append("")
                for insight in removed_error_handlers:
                    script_lines.append(f"// {insight.description}")
                    script_lines.append(f"// WARNING: Error handling removed - {insight.exploit_potential}")
                    script_lines.append(f'bp DriverB!{insight.function_name} ".echo \\"[VULN] Hit function with removed error handling: {insight.function_name}\\"; .printf \\"Risk: {insight.exploit_potential}\\"; g"')
                    script_lines.append("")

            # Generate breakpoints for all changed functions (general monitoring)
            all_changed_functions = self._get_changed_functions(diff_results)
            if all_changed_functions:
                script_lines.append("// ALL CHANGED FUNCTIONS - GENERAL MONITORING")
                script_lines.append("")
                for func_addr, func_name in all_changed_functions.items():
                    bp_command = f'bp DriverB!{func_name} ".echo \\"[MODIFIED] Hit changed function {func_name} (0x{func_addr:08X})\\"; g"'
                    script_lines.append(f"// Changed function: {func_name}")
                    script_lines.append(bp_command)
                    script_lines.append("")

            # Add advanced analysis functions
            script_lines.append("// ADVANCED ANALYSIS FUNCTIONS")
            script_lines.append("")

            # IOCTL analysis function
            script_lines.append("function analyzeIoctlDispatch() {")
            script_lines.append("    host.diagnostics.debugLog('[+] Analyzing IOCTL dispatch routines...\\n');")
            script_lines.append("    ")
            script_lines.append("    // Monitor common IOCTL dispatch patterns")
            script_lines.append("    var ioctlDispatchers = [")
            script_lines.append("        'IoGetCurrentIrpStackLocation',")
            script_lines.append("        'IoCallDriver',")
            script_lines.append("        'IofCallDriver'")
            script_lines.append("    ];")
            script_lines.append("    ")
            script_lines.append("    for (var i = 0; i < ioctlDispatchers.length; i++) {")
            script_lines.append("        try {")
            script_lines.append("            var addr = host.getModuleSymbolAddress('DriverB', ioctlDispatchers[i]);")
            script_lines.append("            if (addr != null) {")
            script_lines.append("                host.diagnostics.debugLog('Found IOCTL dispatcher: ' + ioctlDispatchers[i] + ' at ' + addr.toString(16) + '\\n');")
            script_lines.append("            }")
            script_lines.append("        } catch (e) {}")
            script_lines.append("    }")
            script_lines.append("}")
            script_lines.append("")

            # Data flow tracing function
            script_lines.append("function traceDataFlow(inputAddr, sinkAddr) {")
            script_lines.append("    host.diagnostics.debugLog('[+] Tracing data flow from 0x' + inputAddr.toString(16) + ' to 0x' + sinkAddr.toString(16) + '\\n');")
            script_lines.append("    ")
            script_lines.append("    // Set watchpoint on input buffer")
            script_lines.append("    host.diagnostics.debugLog('Setting watchpoint on input data...\\n');")
            script_lines.append("    // Note: Actual watchpoint implementation depends on specific vulnerability")
            script_lines.append("    ")
            script_lines.append("    // Common dangerous sinks to monitor")
            script_lines.append("    var dangerousSinks = [")
            script_lines.append("        'memcpy', 'memmove', 'strcpy', 'strncpy',")
            script_lines.append("        'ExAllocatePool', 'ExAllocatePoolWithTag',")
            script_lines.append("        'RtlCopyMemory', 'ZwWriteFile'")
            script_lines.append("    ];")
            script_lines.append("    ")
            script_lines.append("    host.diagnostics.debugLog('Monitoring dangerous sink functions...\\n');")
            script_lines.append("    for (var i = 0; i < dangerousSinks.length; i++) {")
            script_lines.append("        try {")
            script_lines.append("            host.executeCommand('bp ' + dangerousSinks[i] + ' \".echo \\\"[SINK] Hit dangerous function ' + dangerousSinks[i] + '\\\"; g\"');")
            script_lines.append("        } catch (e) {}")
            script_lines.append("    }")
            script_lines.append("}")
            script_lines.append("")

            # Vulnerability assessment function
            script_lines.append("function assessVulnerability() {")
            script_lines.append("    host.diagnostics.debugLog('[+] Running vulnerability assessment...\\n');")
            script_lines.append("    ")
            script_lines.append("    // Check for common vulnerability patterns")
            script_lines.append("    var vulnPatterns = {")
            script_lines.append("        'unchecked_allocation': ['ExAllocatePool', 'malloc'],")
            script_lines.append("        'buffer_operations': ['memcpy', 'memmove', 'RtlCopyMemory'],")
            script_lines.append("        'arithmetic': ['add', 'sub', 'mul', 'div'],")
            script_lines.append("        'pointer_ops': ['lea', 'mov', 'push']")
            script_lines.append("    };")
            script_lines.append("    ")
            script_lines.append("    host.diagnostics.debugLog('Vulnerability patterns loaded. Use traceDataFlow() for specific analysis.\\n');")
            script_lines.append("}")
            script_lines.append("")

            # Helper function to get IOCTL codes
            script_lines.append("function getIoctlCodes() {")
            script_lines.append("    host.diagnostics.debugLog('[+] Extracting IOCTL codes from current context...\\n');")
            script_lines.append("    ")
            script_lines.append("    // Try to extract IOCTL code from IRP")
            script_lines.append("    try {")
            script_lines.append("        var irp = host.currentThread.Registers.rip; // Simplified - actual implementation needs proper IRP parsing")
            script_lines.append("        host.diagnostics.debugLog('IRP context found - extract IOCTL code manually\\n');")
            script_lines.append("    } catch (e) {")
            script_lines.append("        host.diagnostics.debugLog('No active IRP context found\\n');")
            script_lines.append("    }")
            script_lines.append("}")
            script_lines.append("")

            # Main analysis workflow
            script_lines.append("// MAIN ANALYSIS WORKFLOW")
            script_lines.append("// Call these functions in order for comprehensive analysis")
            script_lines.append("")
            script_lines.append("// 1. Analyze IOCTL dispatch")
            script_lines.append("analyzeIoctlDispatch();")
            script_lines.append("")
            script_lines.append("// 2. Run vulnerability assessment")
            script_lines.append("assessVulnerability();")
            script_lines.append("")
            script_lines.append("// 3. Extract IOCTL codes (call when IRP is available)")
            script_lines.append("// getIoctlCodes();")
            script_lines.append("")
            script_lines.append("// 4. Setup breakpoints for all identified targets")
            script_lines.append("host.diagnostics.debugLog('[+] All breakpoints and analysis functions loaded.\\n');")
            script_lines.append("host.diagnostics.debugLog('[+] Start your analysis by triggering the vulnerable IOCTL.\\n');")
            script_lines.append("")

            # Write to file
            script_content = "\n".join(script_lines)

            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(script_content)

            logger.info(f"Generated enhanced WinDbg script: {output_path}")
            return output_path

        except Exception as e:
            logger.error(f"Failed to generate WinDbg script: {e}")
            return ""

    def _analyze_security_insights(self, diff_results: Dict[str, Any]) -> List[SecurityInsight]:
        """
        Analyze comparison results for comprehensive security insights.
        Enhanced to provide detailed vulnerability assessment and exploit potential.

        Args:
            diff_results: Results from logic flow comparison

        Returns:
            List of security insights with detailed analysis
        """
        insights = []

        # Get detailed analysis from various comparison sections
        logic_comparison = diff_results.get("logic_equivalence", {})
        role_differences = logic_comparison.get("role_distribution", {}).get("differences", {})
        attack_surface = diff_results.get("attack_surface_analysis", {})
        patch_classification = diff_results.get("patch_classification", {})
        structural_comparison = diff_results.get("structural_comparison", {})

        # Analyze added validation routines (security improvements)
        validation_diff = role_differences.get("validation_routine", 0)
        if validation_diff > 0:  # Graph B has more validation
            insight = SecurityInsight(
                function_address=0,  # Will be filled by caller
                function_name="Multiple Functions",
                change_type=ChangeType.ADDED_SECURITY_CHECK,
                risk_level="MEDIUM",
                description=f"Added {validation_diff} validation routines - potential vulnerability fix",
                exploit_potential="Check if input validation was missing in original version. May indicate previous bypass vulnerability.",
                reachable_from_ioctl=False  # Aggregate analysis
            )
            insights.append(insight)

        # Analyze removed error handlers (potential security degradation)
        error_diff = role_differences.get("error_handler", 0)
        if error_diff < 0:  # Graph B has fewer error handlers
            insight = SecurityInsight(
                function_address=0,
                function_name="Multiple Functions",
                change_type=ChangeType.REMOVED_CODE,
                risk_level="HIGH",
                description=f"Removed {abs(error_diff)} error handlers - potential security regression",
                exploit_potential="Error handling removed, may lead to crashes or undefined behavior. High exploit potential if combined with input validation removal.",
                reachable_from_ioctl=False
            )
            insights.append(insight)

        # Analyze handle lifecycle changes (resource management vulnerabilities)
        handle_analysis = diff_results.get("handle_lifecycle_comparison", {})
        handle_balance_a = handle_analysis.get("acquire_release_balance_a", 0)
        handle_balance_b = handle_analysis.get("acquire_release_balance_b", 0)

        if handle_balance_b < handle_balance_a:  # More unbalanced in Graph B
            insight = SecurityInsight(
                function_address=0,
                function_name="Handle Management",
                change_type=ChangeType.REMOVED_CODE,
                risk_level="HIGH",
                description=f"Handle lifecycle imbalance worsened (A: {handle_balance_a}, B: {handle_balance_b})",
                exploit_potential="Potential handle leaks or double-free vulnerabilities. May lead to privilege escalation.",
                reachable_from_ioctl=False
            )
            insights.append(insight)

        # Analyze attack surface changes
        reachable_functions = attack_surface.get("reachable_functions", [])
        for func_info in reachable_functions:
            func_addr = func_info.get("address", 0)
            func_name = func_info.get("name", f"sub_{func_addr:08X}")
            change_type = func_info.get("change_type", ChangeType.UNKNOWN)

            # Assess risk based on change type and reachability
            risk_level = "LOW"
            exploit_potential = ""

            if change_type == ChangeType.ADDED_SECURITY_CHECK:
                risk_level = "LOW"  # Security improvement
                exploit_potential = "Security patch applied - less likely to be exploitable"
            elif change_type == ChangeType.REMOVED_CODE:
                risk_level = "HIGH"
                exploit_potential = "Code removal in IOCTL-reachable function - high exploit potential"
            elif change_type == ChangeType.LOGIC_REORDER:
                risk_level = "MEDIUM"
                exploit_potential = "Logic flow changed - may introduce race conditions or bypass opportunities"

            insight = SecurityInsight(
                function_address=func_addr,
                function_name=func_name,
                change_type=change_type,
                risk_level=risk_level,
                description=f"IOCTL-reachable function {func_name} has {change_type.value.replace('_', ' ')}",
                exploit_potential=exploit_potential,
                reachable_from_ioctl=True,
                ioctl_codes=func_info.get("ioctl_codes", [])
            )
            insights.append(insight)

        # Analyze dangerous function exposure
        dangerous_functions = ["memcpy", "memmove", "strcpy", "ExAllocatePool", "RtlCopyMemory"]
        for func_name in dangerous_functions:
            exposure_a = structural_comparison.get("functions_a", {}).get(func_name, 0)
            exposure_b = structural_comparison.get("functions_b", {}).get(func_name, 0)

            if exposure_b > exposure_a and exposure_b > 0:
                insight = SecurityInsight(
                    function_address=0,  # Generic dangerous function
                    function_name=func_name,
                    change_type=ChangeType.UNKNOWN,
                    risk_level="MEDIUM",
                    description=f"Increased usage of dangerous function {func_name} (A: {exposure_a}, B: {exposure_b})",
                    exploit_potential=f"More exposure to {func_name} vulnerabilities. Check if size validation is adequate.",
                    reachable_from_ioctl=False
                )
                insights.append(insight)

        return insights

    def _get_changed_functions(self, diff_results: Dict[str, Any]) -> Dict[int, str]:
        """
        Extract changed functions from comparison results.

        Args:
            diff_results: Comparison results

        Returns:
            Dict of function address -> function name
        """
        changed_functions = {}

        # Extract from structural comparison
        structural = diff_results.get("structural_comparison", {})
        graph_a_functions = structural.get("functions_a", {})
        graph_b_functions = structural.get("functions_b", {})

        # Find functions that exist in both but differ
        common_functions = set(graph_a_functions.keys()) & set(graph_b_functions.keys())
        for func_addr in common_functions:
            if graph_a_functions[func_addr] != graph_b_functions[func_addr]:
                changed_functions[func_addr] = graph_b_functions[func_addr]

        return changed_functions

    def classify_patch_change(self, graph_a, graph_b, function_addr: int) -> ChangeType:
        """
        Classify the type of change for a specific function.

        Args:
            graph_a: Original graph
            graph_b: Patched graph
            function_addr: Function address to analyze

        Returns:
            ChangeType classification
        """
        try:
            node_a = graph_a.nodes.get(function_addr)
            node_b = graph_b.nodes.get(function_addr)

            if not node_a or not node_b:
                return ChangeType.UNCHANGED

            # Check for added security validation
            if self._has_security_validation(node_b) and not self._has_security_validation(node_a):
                return ChangeType.ADDED_SECURITY_CHECK

            # Check for removed code
            callees_a = graph_a.get_callees(function_addr)
            callees_b = graph_b.get_callees(function_addr)

            if len(callees_a) > len(callees_b) and len(callees_b) < len(callees_a) // 2:
                return ChangeType.REMOVED_CODE

            # Check for logic reordering (same nodes, different edges)
            if set(callees_a) == set(callees_b) and callees_a != callees_b:
                return ChangeType.LOGIC_REORDER

            return ChangeType.UNCHANGED

        except Exception as e:
            logger.warning(f"Error classifying change for function 0x{function_addr:08X}: {e}")
            return ChangeType.UNKNOWN

    def _has_security_validation(self, node) -> bool:
        """Check if a node contains security validation"""
        if not node:
            return False

        # Check function name for security patterns
        func_name = node.name.lower()
        for pattern_set in self._security_patterns.values():
            if any(pattern.lower() in func_name for pattern in pattern_set):
                return True

        return False

    def find_attack_surface(self, graph, target_function: int) -> Dict[str, Any]:
        """
        Find attack surface for a target function (IOCTL reachability).

        Args:
            graph: Logic graph to analyze
            target_function: Function address to check reachability

        Returns:
            Attack surface analysis
        """
        attack_surface = {
            "reachable_from_ioctl": False,
            "ioctl_dispatchers": [],
            "path_length": 0,
            "entry_points": []
        }

        try:
            # Find IRP dispatchers in the graph
            irp_dispatchers = []
            for node in graph.nodes.values():
                if node.role.value == "irp_dispatcher":
                    irp_dispatchers.append(node.ea)

            # Check if target function is reachable from any dispatcher
            for dispatcher in irp_dispatchers:
                path = graph.get_path_to_anchor(target_function)
                if path and dispatcher in path:
                    attack_surface["reachable_from_ioctl"] = True
                    attack_surface["ioctl_dispatchers"].append(dispatcher)
                    attack_surface["path_length"] = len(path)
                    attack_surface["entry_points"].append(f"0x{dispatcher:08X}")

                    # Try to extract IOCTL code (simplified)
                    ioctl_code = self._extract_ioctl_code(graph, dispatcher)
                    if ioctl_code:
                        attack_surface["ioctl_codes"] = [ioctl_code]

        except Exception as e:
            logger.warning(f"Error analyzing attack surface for 0x{target_function:08X}: {e}")

        return attack_surface

    def _extract_ioctl_code(self, graph, dispatcher_addr: int) -> Optional[str]:
        """
        Extract IOCTL code from dispatcher function (simplified implementation).

        Args:
            graph: Logic graph
            dispatcher_addr: Dispatcher function address

        Returns:
            IOCTL code string if found
        """
        # This would require more sophisticated analysis in a real implementation
        # For now, return a placeholder
        return "IOCTL_UNKNOWN"

    def generate_exploit_template(self, insights: List[SecurityInsight]) -> str:
        """
        Generate a basic exploit template based on security insights.

        Args:
            insights: List of security insights

        Returns:
            Exploit template code
        """
        template_lines = []
        template_lines.append("//" + "="*50)
        template_lines.append("// AUTO-GENERATED EXPLOIT TEMPLATE")
        template_lines.append("// Based on Logic Flow Analysis Security Insights")
        template_lines.append("//" + "="*50)
        template_lines.append("")
        template_lines.append("#include <windows.h>")
        template_lines.append("#include <winioctl.h>")
        template_lines.append("#include <stdio.h>")
        template_lines.append("")
        template_lines.append("int main() {")
        template_lines.append("    HANDLE hDevice;")
        template_lines.append("    DWORD bytesReturned;")
        template_lines.append("")
        template_lines.append("    // Open device handle")
        template_lines.append('    hDevice = CreateFileA("\\\\.\\\\VulnerableDevice",')
        template_lines.append("        GENERIC_READ | GENERIC_WRITE,")
        template_lines.append("        0, NULL, OPEN_EXISTING,")
        template_lines.append("        FILE_ATTRIBUTE_NORMAL, NULL);")
        template_lines.append("")
        template_lines.append("    if (hDevice == INVALID_HANDLE_VALUE) {")
        template_lines.append('        printf("Failed to open device\\n");')
        template_lines.append("        return 1;")
        template_lines.append("    }")
        template_lines.append("")

        # Add IOCTL calls based on insights
        ioctl_count = 1
        for insight in insights:
            if insight.ioctl_codes:
                for ioctl_code in insight.ioctl_codes:
                    template_lines.append(f"    // IOCTL {ioctl_count}: {insight.description}")
                    template_lines.append("    DWORD inputBuffer[64] = {0}; // Craft malicious input")
                    template_lines.append(f"    DeviceIoControl(hDevice, {ioctl_code},")
                    template_lines.append("        inputBuffer, sizeof(inputBuffer),")
                    template_lines.append("        NULL, 0, &bytesReturned, NULL);")
                    template_lines.append("")
                    ioctl_count += 1

        template_lines.append("    CloseHandle(hDevice);")
        template_lines.append("    return 0;")
        template_lines.append("}")
        template_lines.append("")

        return "\n".join(template_lines)
